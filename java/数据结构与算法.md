数据结构与算法：[简介](https://www.cnblogs.com/ysocean/p/7889153.html)

- 线性结构
  - 数组
  - 栈
  - 队列
  - 链表
    - 单链表
    - 双链表
- 树形结构
  - 二叉树
  - 红黑树
  - 哈夫曼树
  - 2-3-4树？
  - AVL树？
  - 伸展树？
- 堆
  - 二叉堆
  - 左倾堆？
  - 斜堆？
  - 二项堆？
  - 斐波那契堆？
- 哈希表
- 图？
- 递归和回溯

  - 分治策略
  - 斐波那切数列
  - 迷宫问题

  - 汉诺塔问题
  - 背包问题
  - 八皇后问题
- 排序算法
  - 冒泡排序
  - 选择排序
  - 插入排序
- 查找算法？
- 其他算法
  - 动态规划？
  - 贪心算法？
  - 字符串匹配？



## 线性结构

### 数组

[Java数据结构和算法（二）——数组](https://www.cnblogs.com/ysocean/p/7894448.html)



### 栈

#### 用数组实现栈

>  参考文章：[Java数据结构和算法（四）——栈](https://www.cnblogs.com/ysocean/p/7911910.html)

##### 代码练习

```java
import java.util.Arrays;
import java.util.EmptyStackException;

/*
* 利用数组实现栈，该栈可接收任何类型的数据，并且可自动扩容。
* */

public class MyStack {

    public static void main(String[] args){
        //填写测试代码
    }

    private Object[] array;
    private int top = -1;  //栈顶指针
    private int size;      //自定义栈容量
						
    //栈的默认总容量为10
    public MyStack(){
        this.array = new Object[10];
        this.size = 10;
    }

    public MyStack(int volume){
        if(volume < 0){
            throw new IllegalArgumentException("栈初始容量不能小于0: "+volume);
        }
        this.array = new Object[volume];
        this.size = volume;
    }

    public boolean isEmpty(){
        return (top == -1);
    }

    //压入元素
    public void push(Object element){
        //判断是否需要扩容？
        isEnlarge(top+1);
        this.array[++top] = element;
    }

    //弹出栈顶元素
    public Object pop(){
        if(top == -1){
            throw new EmptyStackException();
        }else{
            return this.array[top--];
        }
    }

    //获取栈顶元素
    public Object getPeek(){
        if(top == -1){
            throw new EmptyStackException();
        }else{
            return this.array[top];
        }
    }

    //删除栈顶元素
    public void delTop(){
        if(top != -1)
        top = top - 1;
    }

    public void isEnlarge(int currentTop){
        int lastSize = size;
        //如果新元素入栈后容量大于先前规定的总容量，则将其扩容至原来两倍
        if(currentTop >= lastSize){
            //暂存扩容后栈的容量
            int newSize = 0;
            //判断乘2后是否溢出
            if((lastSize<<1) < Integer.MAX_VALUE){
                newSize = (lastSize<<1);
            }else{
                newSize = Integer.MAX_VALUE;
            }
            this.size = newSize;
            //扩容数组
            array = Arrays.copyOf(array,size);
        }
    }
}
```



#### 用单向链表实现栈





#### 前缀、中缀、后缀表达式(逆波兰表达式)

> 参考文章：[前缀、中缀、后缀表达式(逆波兰表达式)](https://www.cnblogs.com/chensongxian/p/7059802.html)



### 队列

#### 数组实现队列

> 参考文章：[Java数据结构和算法（五）——队列](https://www.cnblogs.com/ysocean/p/7921930.html)



#### 双端链表实现队列



### 链表

> 参考文章：[Java数据结构和算法（七）——链表](https://www.cnblogs.com/ysocean/p/7928988.html)

#### 单向链表

#### 有序链表

#### 双端链表

#### 双向链表



## 树形结构

### 二叉树

#### 二叉搜索（查找）树

> 参考文章：[[Java数据结构和算法（十）——二叉树](https://www.cnblogs.com/ysocean/p/8032642.html)](https://www.cnblogs.com/ysocean/p/8032642.html)



#### 红黑树

> 参考文章：[Java数据结构和算法（十一）——红黑树](https://www.cnblogs.com/ysocean/p/8004211.html)



#### 哈夫曼树

> 参考文章：[[哈夫曼树(三)之 Java详解](https://www.cnblogs.com/skywang12345/p/3706833.html)](https://www.cnblogs.com/skywang12345/p/3706833.html)



## 堆

### 二叉堆（最大堆、最小堆）

> [Java数据结构和算法（十四）——堆](https://www.cnblogs.com/ysocean/p/8032660.html)



## 哈希表

> 参考文章：[ Java数据结构和算法（十三）——哈希表](https://www.cnblogs.com/ysocean/p/8032656.html)



## 递归和回溯

**递归的概念**

简单的说: **递归就是方法自己调用自己**,每次调用时**传入不同的变量**.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。

**递归的调用机制**

![](https://gitee.com/aduncmj/PictureBed/raw/master/images/2019-11-18_152416.png)



**递归需要遵守的重要准则**

1)      执行一个方法时，就创建一个新的受保护的独立空间(栈空间)

2)      方法的局部变量是独立的，不会相互影响, 比如 n 变量

3)      如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.

4)      递归**必须向退出递归的条件逼近**，否则就是无限递归,出现 StackOverflowError

5)      当一个方法执行完毕，或者遇到 return，就会返回，**遵守谁调用，就将结果返回给谁**，同时当方法执行完毕或者返回时，该方法也就执行完毕



### 分治算法（策略）

当我们求解某些问题时，由于这些问题要处理的数据相当多，或求解过程相当复杂，使得直接求解法在时间上相当长，或者根本无法直接求出。对于这类问题，我们往往先把它分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。如果这些子问题还较大，难以解决，可以再把它们分成几个更小的子问题，以此类推，直至可以直接求出解为止。这就是分治策略的基本思想。

递归的二分查找法就是一个分治算法的典型例子，分治算法常常是一个方法，在这个方法中含有两个对自身的递归调用，分别对应于问题的两个部分。



### 斐波那契数列

> 问题描述：斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34....，即第一项 f(1) = 1,第二项 f(2) = 1.....,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。

代码实现：

```java
int f(int n){
    // 1.先写递归结束条件
    if(n <= 2){
        return 1;
    }
    // 2.接着写等价关系式
    return f(n-1) + f(n - 2);
}
```

### 迷宫问题

![](https://gitee.com/aduncmj/PictureBed/raw/master/images/2019-11-07_142935.png)

代码实现：

```java
public class MiGong {
    public static void main(String[] args) {
        // 先创建一个二维数组，模拟迷宫
        // 地图
        int[][] map = new int[8][7];
        // 使用 1 表示墙
        // 上下全部置为 1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        // 左右全部置为 1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //设置挡板, 1  表示
        map[3][1] = 1;
        map[3][2] = 1;

        // 输出地图
        System.out.println("地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

        //使用递归回溯给小球找路
        setWay(map, 1, 1);
        
        //输出新的地图, 小球走过，并标识过的递归
        System.out.println("小球走过，并标识过的 地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

    }
        //使用递归回溯来给小球找路
        //说明
        //1. map 表示地图
        //2. i,j 表示从地图的哪个位置开始出发 (1,1)
        //3. 如果小球能到 map[6][5] 位置，则说明通路找到.
        //4.  约定： 当 map[i][j] 为 0  表示该点没有走过 当为 1  表示墙	； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
        //5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 ,  如果该点走不通，再回溯

        /**
         * @param map 表示地图
         * @param i 从哪个位置开始找
         * @param j
         * @return 如果找到通路，就返回 true,  否则返回 false
         */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) { // 通路已经找到 ok
            return true;
        } else {
            if (map[i][j] == 0) { //如果当前这个点还没有走过
                // 按照策略 下->右->上->左 走
                map[i][j] = 2;// 假定该点是可以走通. 
                if(setWay(map, i+1, j)) {//向下走
                    return true;
                } else if (setWay(map, i, j + 1)) { //向右走
                    return true;
                } else if (setWay(map, i - 1, j)) { //向上
                    return true;
                } else if (setWay(map, i, j - 1)) { //向左走
                    return true;
                } else {
                    //说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else{ // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                    return false;
            }
    }
}
```







## 排序算法

![摘自-https://www.cnblogs.com/guoyaohua/p/8600214.html](https://gitee.com/aduncmj/PictureBed/raw/master/images/递归调用机制.jpg)

### 冒泡排序

> 参考文章：[ Java数据结构和算法（三）——冒泡、选择、插入排序算法](https://www.cnblogs.com/ysocean/p/7896269.html)



### 选择排序

> 参考文章：[ Java数据结构和算法（三）——冒泡、选择、插入排序算法](https://www.cnblogs.com/ysocean/p/7896269.html)



### 直接插入排序

> 参考文章：[排序三 直接插入排序](https://www.cnblogs.com/jingmoxukong/p/4303270.html)



### 希尔排序

> 参考文章：[排序四 希尔排序](https://www.cnblogs.com/jingmoxukong/p/4303279.html)



### 归并排序

> 参考文章：[排序七 归并排序](https://www.cnblogs.com/jingmoxukong/p/4308823.html)



### 快速排序

> 参考文章：[排序二 快速排序](https://www.cnblogs.com/jingmoxukong/p/4302891.html)



### 堆排序

> 参考文章：[排序六 堆排序](https://www.cnblogs.com/jingmoxukong/p/4303826.html)



### 计数排序&桶排序

> 参考文章：[这或许是东半球讲十大排序算法最好的一篇文章](https://juejin.im/post/5cff49e75188257a6b40de80#heading-32)



### 基数排序

> 参考文章：[排序八 基数排序](https://www.cnblogs.com/jingmoxukong/p/4311237.html)



## 查找算法

> 参考文章：[【算法】先生，您点的查找套餐到了（二分、插值和斐波那契查找）](https://www.cnblogs.com/penghuwan/p/8021809.html)

### 二分查找？

### 插值查找

### 斐波那契查找