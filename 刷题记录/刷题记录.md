### 

五毒神掌 by 覃超

![](images\2020-07-17_212953.png)



### Hot 100

#### 001 两数之和

##### 解法一：暴力法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = {};
        label:
        for(int i = 0; i < nums.length; i++){
            for(int j = i + 1; j < nums.length; j++){
                if(nums[i] + nums[j] == target){
                    result = new int[]{i,j};
                    break label;
                }
            }
        }

        //throw new IllegalArgumentException("No two sum solution");

        return result;
    }
}
```

**复杂度分析：**

时间复杂度：O(n2)

空间复杂度：O(1)



##### 解法二：哈希表 √

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        return null;
        //throw new IllegalArgumentException("No two sum solution");
    }
}
```

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n)



#### 002 两数相加

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public static ListNode addTwoNumbers(ListNode l1, ListNode l2){
        ListNode preHead = new ListNode(0);
        ListNode preHead1 = preHead;
        
        int carry = 0;
        while(l1 != null | l2 != null){
            int x = (l1 != null)? l1.val : 0;
            int y = (l2 != null)? l2.val : 0;
            int sum = (x + y + carry);
            carry = sum / 10;
            preHead1.next = new ListNode(sum%10);

            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;

            preHead1 = preHead1.next;
        }
        
        if(carry > 0){
            preHead1.next = new ListNode(carry);
        }

        return preHead.next;
         
    }
}
```

**复杂度分析：**

时间复杂度：O(max⁡(m,n))

空间复杂度：O(max⁡(m,n))



#### 003 无重复字符的最长子串

##### 方法一：

```java
class Solution {
    //滑动窗口，left窗口每次移动一格
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<Character>();
        int n = s.length();
        int maxLength = 0, right = 0;

        for(int left = 0; left < n; left++){

            while(right < n && !set.contains(s.charAt(right))){
                set.add(s.charAt(right));
                right++;
            }

            set.remove(s.charAt(left));


            maxLength = Math.max(right - left, maxLength);
        } 

        return maxLength;

    }
}
```

**复杂度分析：**

时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。

空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128)内的字符，即 ∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。

方法二：



#### 004 寻找两个正序数组的中位数

```java
class Solution {
    //思路：找出两个数组中的第k小个数，此处k=(nums1.length+nums2.length)/2
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        int k = (len1 + len2)/2;
        //判断两个数组总长度奇偶性
        boolean isOdd = ((len1 + len2) & 1) == 0? false : true;
        //int isOdd = (len1 + len2) % 2;
        //用&判断奇偶比用%效率高

        if(isOdd){
            return getKth(nums1, 0, len1-1, nums2, 0, len2-1, k+1);
        }else{
            return (getKth(nums1, 0, len1-1, nums2, 0, len2-1, k) + getKth(nums1, 0, len1-1, nums2, 0, len2-1, k+1))*0.5;
        }
    }

    public int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //递归出口
        if(len1 == 0) return nums2[start2+k-1];
        if(len2 == 0) return nums1[start1+k-1];
        if(k==1){return Math.min(nums1[start1],nums2[start2]);} 

        //处理len比k/2小的情况
        int i = start1 + Math.min(len1, k/2) -1;
        int j = start2 + Math.min(len2, k/2) -1;

        if(nums1[i] < nums2[j]){
            return getKth(nums1, i+1, end1, nums2, start2, end2, k-(i-start1+1));
        }else{
            return getKth(nums1, start1, end1, nums2, j+1, end2, k-(j-start2+1));
        }
        
    }

}  

```

**复杂度分析：**

时间复杂度：每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 O(log(k)，而 k=(m+n)/2，所以最终的复杂也就是 **O(log(m+n）**。

空间复杂度：虽然我们用到了递归，但是可以看到这个递归**属于尾递归，所以编译器不需要不停地堆栈**，所以空间复杂度为 **O(1)**。



#### 169 多数元素

```java
class Solution {
    public int majorityElement(int[] nums){
        Map<Integer, Integer> countNums = new HashMap<Integer, Integer>();
        for(int num : nums){
            if(!countNums.containsKey(num)){
                countNums.put(num, 1);
            }else{
                countNums.put(num, countNums.get(num) + 1);
            }
        }

        //比较之后需要获取整个entry，因为不能从值推出键。
        Map.Entry<Integer, Integer> majorityEntry = null;

        for(Map.Entry<Integer, Integer> entry : countNums.entrySet()){
            if(majorityEntry == null || entry.getValue() > majorityEntry.getValue()){
                majorityEntry = entry;
            }
        }

        return majorityEntry.getKey();
    }
}
```

**复杂度分析：**

时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们遍历数组 nums 一次，**对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。**如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 O(n)，那么遍历的时间不会超过 O(n)。因此总时间复杂度为 O(n)。

空间复杂度：O(n)



### 剑指offer

#### 03 数组中重复的数字

##### 解法一：原地置换 √

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int temp;
        for(int i=0;i<nums.length;i++){
            while (nums[i]!=i){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                temp=nums[i];
                nums[i]=nums[temp];
                nums[temp]=temp;
            }
        }
        return -1;
    }
}

```

##### 解法二：哈希表（set）

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> dic = new HashSet<>();
        for(int num : nums) {
            if(dic.contains(num)) return num;
            dic.add(num);
        }
        return -1;
    }
}

```









## 各题型频率



### 数组

![](images/7430894_1569830591035_8361FA23DFD51FBD74ED3E8B998C124D.png)









### 链表

![](images/7430894_1569830509086_8E72661D2242C40ECD146E2DB6D88051.png)







### 二叉树

![](images/7430894_1569830416215_69B05851F2FE58A175066F1E5DA68C38.png)





### 哈希表

![](images/7430894_1569830476289_917532E4CCA96E15E5ABCCCBCA30C9F8.png)



### 堆

![](images/7430894_1569830378686_2F12CDAEBDC3554DF96F114FC25AF0CA.png)



### 二分查找

![](images/7430894_1569830438206_2DED0BE4AF3760A39EADD3F7B142C0CE.png)



### 字符串

![](images/7430894_1569830636331_34FCBC856A5DB26274BBD70943733C55.png)





### 回溯算法

![](images/7430894_1569830492157_2218B69A72F37F724F78897F5FDD823E.png)



### 动态规划

![](images/7430894_1569830356992_26B22FDCA14CCC71D9C5AED4C51B038C.png)



### 贪心算法

![](images/7430894_1569830607323_849827FAC31010F210BE08F718E4B786.png)



### 数学

![](images/7430894_1569830569455_68EE5EDA726C008847C37EEA04FD5081.png)





### 设计

![](images/7430894_1569830524598_E19F53D5492F785E2BB3EBDA16F45B21.png)



### 位运算

![](images/7430894_1569830621814_F51A128AC144687722A39909AB36E9E8.png)





### 广度优先搜索

![](images/7430894_1569830460438_7CA6198DDBED14EBAC4EB3A931025979.png)



### 深度优先搜索

![](images/7430894_1569830548100_401F7030436C0950B3B9C6AFB8906225.png)